<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Midnight Renegade Admin</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <style>
      :root {
        font-family: "Space Mono", "Segoe UI", sans-serif;
        background: #050505;
        color: #fff;
      }
      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }
      header {
        padding: 1rem 1.5rem;
        letter-spacing: 0.15em;
        text-transform: uppercase;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
        flex-wrap: wrap;
      }
      .nav-links {
        display: flex;
        gap: 1rem;
        font-size: 0.85rem;
        flex-wrap: wrap;
        align-items: center;
      }
      .nav-links a {
        color: #fff;
        text-decoration: none;
      }
      .nav-links a:hover {
        color: #00ffc6;
      }
      #map {
        flex: 1;
        height: 0;
        min-height: 400px;
      }
      .panel {
        padding: 1rem 1.5rem 2rem;
        background: rgba(0, 0, 0, 0.65);
        border-top: 1px solid rgba(255, 255, 255, 0.08);
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        align-items: center;
      }
      .panel button {
        padding: 0.6rem 1.5rem;
        border-radius: 999px;
        border: none;
        font-size: 0.95rem;
        letter-spacing: 0.1em;
        text-transform: uppercase;
        cursor: pointer;
        background: #00ffc6;
        color: #050505;
        font-weight: 600;
      }
      .panel button.secondary {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
      }
      .stat-line {
        font-size: 0.95rem;
        margin: 0.15rem 0;
        opacity: 0.85;
      }
      .spirit-pin {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        border: 2px solid rgba(255, 255, 255, 0.8);
        overflow: hidden;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.45);
        background: rgba(0, 0, 0, 0.5);
      }
      .spirit-pin .thumb {
        width: 100%;
        height: 100%;
        background-size: cover;
        background-position: center;
        filter: saturate(1.2);
      }
      .nav-links button {
        background: none;
        border: none;
        color: #fff;
        font-size: 0.85rem;
        cursor: pointer;
        text-decoration: underline;
      }
      .lock-indicator {
        font-size: 0.85rem;
        letter-spacing: 0.08em;
        opacity: 0.75;
      }
      .pin-wrapper {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      .state-chip {
        position: absolute;
        top: -8px;
        right: -8px;
        background: rgba(0, 0, 0, 0.85);
        border-radius: 999px;
        padding: 2px 6px;
        font-size: 0.75rem;
        border: 1px solid rgba(255, 255, 255, 0.3);
      }
      .lock-indicator {
        font-size: 0.85rem;
        letter-spacing: 0.08em;
        opacity: 0.75;
      }
      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        z-index: 1000;
        align-items: center;
        justify-content: center;
      }
      .modal.active {
        display: flex;
      }
      .modal-content {
        background: #1a1a1a;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 18px;
        padding: 2rem;
        min-width: 320px;
        max-width: 90vw;
      }
      .modal-content h3 {
        margin-top: 0;
        margin-bottom: 1.5rem;
      }
      .modal-content label {
        display: block;
        margin-bottom: 0.5rem;
        font-size: 0.9rem;
        opacity: 0.9;
      }
      .modal-content input {
        width: 100%;
        padding: 0.6rem 0.8rem;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(0, 0, 0, 0.4);
        color: #fff;
        font-size: 1rem;
        box-sizing: border-box;
        margin-bottom: 1rem;
      }
      .modal-content .button-group {
        display: flex;
        gap: 0.75rem;
        margin-top: 1.5rem;
      }
      .modal-content button {
        flex: 1;
        padding: 0.75rem 1.25rem;
        border: none;
        border-radius: 999px;
        font-weight: 600;
        letter-spacing: 0.1em;
        text-transform: uppercase;
        cursor: pointer;
      }
      .modal-content button.primary {
        background: #00ffc6;
        color: #050505;
      }
      .modal-content button.secondary {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
      }
      .beacon-pin {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 32px;
      }
      .beacon-pin .pin-body {
        display: inline-flex;
        margin-top: 12px;
      }
      .state-chip {
        background: rgba(0, 0, 0, 0.75);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 999px;
        padding: 2px 8px;
        font-size: 0.8rem;
        pointer-events: none;
        z-index: 2;
        position: absolute;
        top: -6px;
      }
    </style>
  </head>
  <body>
    <header>
      <span>Admin ¬∑ Beacon Management</span>
      <div class="nav-links">
        <a href="/admin/beacons">Beacon Table</a>
        <a href="/admin/spirits">Spirits</a>
        <a href="/admin/data">Data</a>
        <a href="/admin/logout">Logout</a>
      </div>
    </header>
    <div id="map"></div>
    <div class="panel">
      <div>
        <p class="stat-line">Active walkers: <span id="walker-count">0</span></p>
        <p class="stat-line">Mean distance: <span id="mean-distance">0 m</span></p>
      </div>
      <button id="add-beacon-btn" class="secondary">Add Beacon</button>
      <button id="center-btn" class="secondary">Center On Display</button>
      <button id="lock-toggle-btn" class="secondary">Unlock Moves</button>
      <span class="lock-indicator" id="lock-indicator">Locked</span>
    </div>

    <div id="beacon-modal" class="modal">
      <div class="modal-content">
        <h3 id="modal-title">Add Beacon</h3>
        <label>
          Search Radius (meters)
          <input type="number" id="radius-input" min="1" max="10000" value="100" step="1" />
        </label>
        <div class="button-group">
          <button class="primary" id="save-beacon-btn">Save</button>
          <button class="secondary" id="cancel-beacon-btn">Cancel</button>
          <button class="danger" id="delete-beacon-btn" style="display: none;">Delete</button>
        </div>
      </div>
    </div>

    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>
    <script>
      const map = L.map("map");
      const tiles = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "¬© OpenStreetMap contributors",
      });
      tiles.addTo(map);

      let displayMarker;
      let beacons = {};
      let spirits = {};
      let spiritsById = {};
      let clientMarkers = {};
      let dropPinMarker = null;
      let editingBeaconId = null;
      let isDropPinMode = false;
      let isBeaconLockEnabled = true;
      let pendingMoves = [];
      const beaconPositions = {};
      const lockBtn = document.getElementById("lock-toggle-btn");
      const lockIndicator = document.getElementById("lock-indicator");
      lockIndicator.textContent = "Locked";
      const STATE_ICONS = {
        undiscovered: "?",
        discovered: "üîç",
        returned: "üî¥",
        vanquished: "üü¢",
      };
      const STATE_LABELS = {
        undiscovered: "Undiscovered",
        discovered: "Discovered",
        returned: "Returned to Rift",
        vanquished: "Vanquished",
      };
      async function fetchDisplayLocation() {
        const response = await fetch("/api/display-location");
        if (!response.ok) {
          throw new Error("Unable to fetch location");
        }
        return await response.json();
      }

      async function fetchBeacons() {
        const response = await fetch("/api/beacons");
        if (!response.ok) return [];
        const data = await response.json();
        return data.beacons;
      }

      async function fetchSpirits() {
        const response = await fetch("/api/spirits");
        if (!response.ok) return [];
        const data = await response.json();
        spirits = data.spirits;
        spiritsById = {};
        for (const spirit of spirits) {
          spiritsById[spirit.id] = spirit;
        }
        return spirits;
      }

      async function fetchClientLocations() {
        const response = await fetch("/api/client-locations");
        if (!response.ok) return;
        const data = await response.json();
        return data.clients;
      }

      async function updateStats() {
        const response = await fetch("/api/state");
        if (!response.ok) return;
        const payload = await response.json();
        document.getElementById("walker-count").textContent = payload.activeClients;
        document.getElementById("mean-distance").textContent =
          payload.meanDistanceMeters.toFixed(1) + " m";
      }

      function createBeaconMarker(beacon) {
        beaconPositions[beacon.id] = { lat: beacon.lat, lon: beacon.lon };
        const spirit = beacon.spiritId ? spiritsById[beacon.spiritId] : null;
        const state = beacon.state || "undiscovered";
        const stateSymbol = STATE_ICONS[state] || "?";
        let pinBody =
          '<div style="background: #00ffc6; width: 20px; height: 20px; border-radius: 50%; border: 2px solid #050505;"></div>';
        let iconSize = [32, 40];
        let iconAnchor = [16, 20];
        if (spirit && spirit.imageUrl) {
          pinBody = `<div class="spirit-pin"><div class="thumb" style="background-image:url('${spirit.imageUrl}')"></div></div>`;
        }
        const iconHtml = `
          <div class="beacon-pin">
            <div class="state-chip">${stateSymbol}</div>
            <div class="pin-body">${pinBody}</div>
          </div>
        `;
        const marker = L.marker([beacon.lat, beacon.lon], {
          draggable: !isBeaconLockEnabled,
          icon: L.divIcon({
            className: spirit ? "beacon-marker spirit-marker" : "beacon-marker",
            html: iconHtml,
            iconSize,
            iconAnchor,
          }),
        });

        marker._beaconId = beacon.id;

        const circle = L.circle([beacon.lat, beacon.lon], {
          radius: beacon.searchRadiusMeters,
          color: "#00ffc6",
          fillColor: "#00ffc6",
          fillOpacity: 0.2,
          weight: 2,
        });

        const tooltipLines = [];
        if (spirit) {
          tooltipLines.push(`<strong>${spirit.name}</strong>`);
          if (spirit.currentActivity) {
            tooltipLines.push(spirit.currentActivity);
          }
        } else {
          tooltipLines.push("Beacon");
        }
        tooltipLines.push(`Status: ${STATE_LABELS[state] || "Unknown"}`);
        tooltipLines.push(`Radius: ${beacon.searchRadiusMeters}m`);
        marker.bindTooltip(tooltipLines.join("<br />"), { direction: "top" });
        marker.bindPopup(
          `Beacon<br>Radius: ${beacon.searchRadiusMeters}m<br>${
            spirit ? `Spirit: ${spirit.name}<br>` : ""
          }<button onclick="window.editBeacon('${beacon.id}')">Edit</button>`
        );

        marker.on("dragend", async () => {
          const position = marker.getLatLng();
          circle.setLatLng(position);
          if (isBeaconLockEnabled) {
            await updateBeacon(beacon.id, position.lat, position.lng, beacon.searchRadiusMeters);
            beaconPositions[beacon.id] = { lat: position.lat, lon: position.lng };
          } else {
            const existing = pendingMoves.find((move) => move.id === beacon.id);
            if (existing) {
              existing.lat = position.lat;
              existing.lon = position.lng;
            } else {
              pendingMoves.push({ id: beacon.id, lat: position.lat, lon: position.lng });
            }
          }
        });

        marker.on("click", () => {
          marker.openPopup();
        });

        marker.addTo(map);
        circle.addTo(map);

        return { marker, circle, id: beacon.id };
      }

      function createClientMarker(client) {
        const marker = L.marker([client.lat, client.lon], {
          icon: L.divIcon({
            className: "client-marker",
            html: '<div style="background: #ff6b6b; width: 12px; height: 12px; border-radius: 50%; border: 2px solid #fff;"></div>',
            iconSize: [12, 12],
            iconAnchor: [6, 6],
          }),
        });

        marker.bindPopup(`Walker ${client.id.substring(0, 8)}`);
        marker.addTo(map);
        return marker;
      }

      async function loadBeacons(force = false) {
        if (!isBeaconLockEnabled && !force) {
          return;
        }
        const beaconList = await fetchBeacons();
        for (const [id, beaconData] of Object.entries(beacons)) {
          map.removeLayer(beaconData.marker);
          map.removeLayer(beaconData.circle);
        }
        beacons = {};
        pendingMoves = [];

        for (const beacon of beaconList) {
          beacons[beacon.id] = createBeaconMarker(beacon);
        }
        setBeaconDragging(!isBeaconLockEnabled);
      }

      async function loadClientLocations() {
        const clients = await fetchClientLocations();
        for (const [id, marker] of Object.entries(clientMarkers)) {
          map.removeLayer(marker);
        }
        clientMarkers = {};

        for (const client of clients) {
          clientMarkers[client.id] = createClientMarker(client);
        }
      }

      function showBeaconModal(lat, lon, beaconId = null) {
        editingBeaconId = beaconId;
        const modal = document.getElementById("beacon-modal");
        const title = document.getElementById("modal-title");
        const deleteBtn = document.getElementById("delete-beacon-btn");
        const radiusInput = document.getElementById("radius-input");

        if (beaconId) {
          title.textContent = "Edit Beacon";
          deleteBtn.style.display = "block";
          const beaconData = beacons[beaconId];
          if (beaconData) {
            radiusInput.value = beaconData.circle.getRadius();
          }
        } else {
          title.textContent = "Add Beacon";
          deleteBtn.style.display = "none";
          radiusInput.value = 100;
        }

        modal.classList.add("active");

        if (!dropPinMarker) {
          dropPinMarker = L.marker([lat, lon], {
            draggable: true,
            icon: L.divIcon({
              className: "drop-pin",
              html: '<div style="background: #ffd700; width: 24px; height: 24px; border-radius: 50%; border: 3px solid #050505; box-shadow: 0 0 0 2px #ffd700;"></div>',
              iconSize: [24, 24],
              iconAnchor: [12, 24],
            }),
          });
          dropPinMarker.addTo(map);
          dropPinMarker.on("drag", () => {
            const pos = dropPinMarker.getLatLng();
            map.panTo(pos);
          });
        } else {
          dropPinMarker.setLatLng([lat, lon]);
        }
        map.setView([lat, lon], Math.max(map.getZoom(), 16));
      }

      function hideBeaconModal() {
        const modal = document.getElementById("beacon-modal");
        modal.classList.remove("active");
        if (dropPinMarker) {
          map.removeLayer(dropPinMarker);
          dropPinMarker = null;
        }
        editingBeaconId = null;
        isDropPinMode = false;
      }

      async function saveBeacon() {
        if (!dropPinMarker) return;
        const pos = dropPinMarker.getLatLng();
        const radius = parseFloat(document.getElementById("radius-input").value);

        if (editingBeaconId) {
          await updateBeacon(editingBeaconId, pos.lat, pos.lng, radius);
        } else {
          await createBeacon(pos.lat, pos.lng, radius);
        }

        hideBeaconModal();
        await loadBeacons(true);
      }

      async function createBeacon(lat, lon, radius) {
        await fetch("/api/beacons", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ lat, lon, search_radius_meters: radius }),
        });
      }

      async function updateBeacon(id, lat, lon, radius) {
        await fetch(`/api/beacons/${id}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ lat, lon, search_radius_meters: radius }),
        });
        beaconPositions[id] = { lat, lon };
      }

      async function deleteBeacon(id) {
        await fetch(`/api/beacons/${id}`, { method: "DELETE" });
        hideBeaconModal();
        await loadBeacons(true);
      }

      window.editBeacon = function (id) {
        const beaconData = beacons[id];
        if (beaconData) {
          const pos = beaconData.marker.getLatLng();
          showBeaconModal(pos.lat, pos.lng, id);
        }
      };

      function setBeaconDragging(enabled) {
        Object.values(beacons).forEach((entry) => {
          if (!entry.marker.dragging) return;
          if (enabled) {
            entry.marker.dragging.enable();
          } else {
            entry.marker.dragging.disable();
          }
        });
      }

      async function applyPendingMoves() {
        for (const move of pendingMoves) {
          const entry = beacons[move.id];
          if (!entry) continue;
          await updateBeacon(move.id, move.lat, move.lon, entry.circle.getRadius());
          beaconPositions[move.id] = { lat: move.lat, lon: move.lon };
        }
        pendingMoves = [];
      }

      function revertPendingMoves() {
        for (const move of pendingMoves) {
          const original = beaconPositions[move.id];
          if (original && beacons[move.id]) {
            beacons[move.id].marker.setLatLng([original.lat, original.lon]);
            beacons[move.id].circle.setLatLng([original.lat, original.lon]);
          }
        }
        pendingMoves = [];
      }

      async function init() {
        const loc = await fetchDisplayLocation();
        const latLng = [loc.lat, loc.lon];
        map.setView(latLng, 16);

        displayMarker = L.marker(latLng, { draggable: true }).addTo(map);
        displayMarker.bindPopup("Volumetric Module");
        displayMarker.on("dragend", async () => {
          const position = displayMarker.getLatLng();
          await fetch("/api/display-location", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ lat: position.lat, lon: position.lng }),
          });
        });

        await fetchSpirits();
        await loadBeacons(true);
        await loadClientLocations();
        setInterval(updateStats, 4000);
        setInterval(loadClientLocations, 5000);
        setInterval(async () => {
          await fetchSpirits();
          await loadBeacons(false);
        }, 8000);
      }

      document.getElementById("add-beacon-btn").addEventListener("click", () => {
        isDropPinMode = true;
        const center = map.getCenter();
        showBeaconModal(center.lat, center.lng);
      });

      document.getElementById("save-beacon-btn").addEventListener("click", saveBeacon);
      document.getElementById("cancel-beacon-btn").addEventListener("click", hideBeaconModal);
      document.getElementById("delete-beacon-btn").addEventListener("click", () => {
        if (editingBeaconId) {
          deleteBeacon(editingBeaconId);
        }
      });

      lockBtn.addEventListener("click", async () => {
        if (isBeaconLockEnabled) {
          isBeaconLockEnabled = false;
          lockBtn.textContent = "Lock Moves";
          lockIndicator.textContent = "Unlocked (drag to queue moves)";
          setBeaconDragging(true);
          pendingMoves = [];
        } else {
          if (pendingMoves.length > 0) {
            const list = pendingMoves
              .map((move) => `‚Ä¢ ${move.id} (${move.lat.toFixed(6)}, ${move.lon.toFixed(6)})`)
              .join("\n");
            const confirmed = window.confirm(
              `Apply the following beacon moves?\n\n${list}`
            );
            if (confirmed) {
              await applyPendingMoves();
            } else {
              revertPendingMoves();
            }
          }
          isBeaconLockEnabled = true;
          lockBtn.textContent = "Unlock Moves";
          lockIndicator.textContent = "Locked";
          setBeaconDragging(false);
          await loadBeacons(true);
        }
      });

      map.on("click", (event) => {
        if (isDropPinMode && dropPinMarker) {
          dropPinMarker.setLatLng(event.latlng);
          map.panTo(event.latlng);
        }
      });

      document.getElementById("center-btn").addEventListener("click", async () => {
        const loc = await fetchDisplayLocation();
        map.setView([loc.lat, loc.lon], 16);
        displayMarker.setLatLng([loc.lat, loc.lon]);
      });

      init();
    </script>
  </body>
</html>
